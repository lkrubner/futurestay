# futurestay

Some experiments in simple web apps using PHP


## To start

Check out the code from Github:

    git clone git@github.com:lkrubner/futurestay.git

    cd futurestay/experiments

PHP does not have as many easy-to-embed web servers as the ecosystem of Java or Javascript offers. In Java or Clojure I can simply embed Jetty, which is a great industrial strength web server. It takes one line of code. With PHP, typically the code is run with Nginx or Apache, both of which take some effort to setup. But PHP does afford us with a simple web server that we can use for the sake of running this app and testing it.

Run this in your terminal:

    php -S 127.0.0.1:8000

And then in your browser you can look at these 3 pages:

    http://127.0.0.1:8000/core.php?path=xml

    http://127.0.0.1:8000/core.php?path=json

    http://127.0.0.1:8000/core.php

Of HTTP status codes, you should get a 200, a 200, and a 404.

To test the rate limit feature, set a cookie with a time in the future. This is a timestamp many years in the future:

    curl --verbose --cookie "recent_request=2651077198" "http://127.0.0.1:8000/core.php?path=json"

Or, open two web browsers and hit refresh quickly in both of them. Sometimes I was able to get this error message in the browser if I hit "refesh" very quickly, but you're at the mercy of what your web browser is doing in the background. This is a stateless rate limit that relies on cookies, as such it would be easy for a user to hack, but anything better would require the maintenance of some state.




## Object Oriented Programming

Please look at the Wikipedia page for Object Oriented Programming:

https://en.wikipedia.org/wiki/Object-oriented_programming

That article contains a section called "Criticism." Search for "Krubner" and you'll see I'm listed there. They link to one of my most famous technical essays, which I wrote in 2014.

For the last few years I've advocated for the Functional Paradigm. I think it is a clean style. I've written a lot of microservices in Clojure, often keeping the entire app in a single file, which, I have found, makes it easier to hand-off to a new programmer who is just learning the code. Arguably, this transfers complexity away from the app and towards the overall system of microservies. I'm happy to have that conversation.

I realize PHP has become increasingly object oriented over the years. While I wrote this app in the same functional style I would use in Clojure, I'm also happy to re-write this as a Laravel app. Please let me know if you'd like to see that.



## Unit tests versus high level functional tests

I've often written about this on my weblog, and I'm happy to discuss further. I'm also happy to adjust to whatever the team's policies are regarding unit tests or high level functional tests. The short version of the argument that I typically make goes like this:

Unit tests are very useful when you have a system where most data is generated internally to the system. So, in your typical CMS, unit tests can be very useful, since users are typically using the system to create the data in the system. In such cases you know the database schema, and so you can validate the structure of your data fairly well. However, when consuming 3rd party APIs, unit tests are less useful. When doing a large ETL project, the most likely source of bugs will be changes or mistakes the 3rd party API that you are trying to use. The crucial fact is that unit tests will rely on mock data, which is easy to provide when your system generates the data, but when the data is generated by some outside company, then your mock data is likely to become obsolete quickly. In such cases, your unit tests will pass, but they really should fail -- they would fail if they interacted with the real data coming from the other company. So in projects that are mostly about consuming APIs, it is best to focus on high level functional tests. So this project includes the `tests.php` file, but no unit tests. Let me know if you'd like to see unit tests, I'm happy to add them in.
